//! Decision Validator for the LLM Orchestrator
//!
//! This module validates decisions generated by the LLM before they are executed,
//! ensuring safety, correctness, and compliance with allowed actions.

use crate::orchestration::error::{OrchestratorError, OrchestratorResult, ValidationErrorDetails};
use crate::orchestration::prompts::{AllowedActions, ParameterBounds, ParameterLimits};
use crate::orchestration::types::{Action, Decision, DecisionType};
use std::collections::HashSet;
use tracing::{debug, info, warn};

/// Result of decision validation
#[derive(Debug, Clone)]
pub enum ValidationResult {
    /// Decision is valid
    Valid,
    /// Decision is invalid with error details
    Invalid {
        error: OrchestratorError,
        details: Vec<ValidationErrorDetails>,
    },
}

impl ValidationResult {
    pub fn is_valid(&self) -> bool {
        matches!(self, Self::Valid)
    }
    
    pub fn error(&self) -> Option<&OrchestratorError> {
        match self {
            Self::Invalid { error, .. } => Some(error),
            Self::Valid => None,
        }
    }
}

/// Safety limits for decision parameters
#[derive(Debug, Clone)]
pub struct SafetyLimits {
    /// Maximum allowed priority
    pub max_priority: u8,
    /// Minimum allowed confidence
    pub min_confidence: f64,
    /// Maximum allowed confidence
    pub max_confidence: f64,
    /// Maximum number of actions per decision
    pub max_actions: usize,
    /// Required fields in actions
    pub required_action_fields: Vec<String>,
}

impl Default for SafetyLimits {
    fn default() -> Self {
        Self {
            max_priority: 10,
            min_confidence: 0.0,
            max_confidence: 1.0,
            max_actions: 5,
            required_action_fields: vec!["action_type".to_string()],
        }
    }
}

/// Trait for decision validation
pub trait DecisionValidatorTrait: Send + Sync {
    /// Validate a complete decision
    fn validate_decision(&self, decision: &Decision, decision_type: DecisionType) -> ValidationResult;
    
    /// Validate a single action
    fn validate_action(&self, action: &Action, decision_type: DecisionType) -> OrchestratorResult<()>;
    
    /// Check if action parameters are within safety limits
    fn check_safety_limits(&self, action: &Action) -> OrchestratorResult<()>;
    
    /// Get a fallback decision for when validation fails
    fn get_fallback_decision(&self, context: &str, decision_type: DecisionType) -> Decision;
}

/// Decision Validator implementation
pub struct DecisionValidator {
    /// Set of allowed actions per decision type
    allowed_actions: HashSet<String>,
    /// Safety limits
    safety_limits: SafetyLimits,
    /// Whether to log validation failures
    log_failures: bool,
    /// Validation statistics
    stats: std::sync::atomic::AtomicU64,
    failed_stats: std::sync::atomic::AtomicU64,
}

impl DecisionValidator {
    /// Create a new decision validator with default settings
    pub fn new() -> Self {
        let all_actions: HashSet<String> = AllowedActions::all()
            .iter()
            .map(|s| s.to_string())
            .collect();
        
        Self {
            allowed_actions: all_actions,
            safety_limits: SafetyLimits::default(),
            log_failures: true,
            stats: std::sync::atomic::AtomicU64::new(0),
            failed_stats: std::sync::atomic::AtomicU64::new(0),
        }
    }
    
    /// Create with custom allowed actions
    pub fn with_allowed_actions(mut self, actions: Vec<String>) -> Self {
        self.allowed_actions = actions.into_iter().collect();
        self
    }
    
    /// Create with custom safety limits
    pub fn with_safety_limits(mut self, limits: SafetyLimits) -> Self {
        self.safety_limits = limits;
        self
    }
    
    /// Disable failure logging
    pub fn without_logging(mut self) -> Self {
        self.log_failures = false;
        self
    }
    
    /// Validate JSON format of a raw LLM output
    pub fn validate_json(&self, raw_output: &str) -> OrchestratorResult<Decision> {
        serde_json::from_str(raw_output).map_err(|e| {
            OrchestratorError::InvalidJsonFormat {
                message: format!("Failed to parse decision JSON: {}", e),
                raw_output: Some(raw_output.to_string()),
            }
        })
    }
    
    /// Validate decision format has all required fields
    fn validate_format(&self, decision: &Decision) -> OrchestratorResult<()> {
        // Check decision name is not empty
        if decision.decision.is_empty() {
            return Err(OrchestratorError::SchemaValidationError {
                message: "Decision name cannot be empty".to_string(),
                field: Some("decision".to_string()),
            });
        }
        
        // Check reasoning is not empty
        if decision.reasoning.is_empty() {
            return Err(OrchestratorError::SchemaValidationError {
                message: "Decision reasoning cannot be empty".to_string(),
                field: Some("reasoning".to_string()),
            });
        }
        
        // Check confidence is valid
        if decision.confidence < self.safety_limits.min_confidence
            || decision.confidence > self.safety_limits.max_confidence
        {
            return Err(OrchestratorError::InvalidConfidence {
                value: decision.confidence,
            });
        }
        
        // Check number of actions
        if decision.actions.len() > self.safety_limits.max_actions {
            return Err(OrchestratorError::SchemaValidationError {
                message: format!(
                    "Too many actions: {} (max: {})",
                    decision.actions.len(),
                    self.safety_limits.max_actions
                ),
                field: Some("actions".to_string()),
            });
        }
        
        Ok(())
    }
    
    /// Validate that actions are in the allowed list for the decision type
    fn validate_action_allowed(
        &self,
        action: &Action,
        decision_type: DecisionType,
    ) -> OrchestratorResult<()> {
        let allowed_for_type: HashSet<String> = AllowedActions::for_type(decision_type)
            .iter()
            .map(|s| s.to_string())
            .collect();
        
        if !allowed_for_type.contains(&action.action_type) {
            return Err(OrchestratorError::ActionNotAllowed {
                action: action.action_type.clone(),
                allowed_actions: allowed_for_type.into_iter().collect(),
            });
        }
        
        Ok(())
    }
    
    /// Validate action priority
    fn validate_priority(&self, action: &Action) -> OrchestratorResult<()> {
        if action.priority > self.safety_limits.max_priority {
            return Err(OrchestratorError::ParameterOutOfBounds {
                param_name: "priority".to_string(),
                value: action.priority.to_string(),
                min: "1".to_string(),
                max: self.safety_limits.max_priority.to_string(),
            });
        }
        
        if action.priority == 0 {
            return Err(OrchestratorError::ParameterOutOfBounds {
                param_name: "priority".to_string(),
                value: "0".to_string(),
                min: "1".to_string(),
                max: self.safety_limits.max_priority.to_string(),
            });
        }
        
        Ok(())
    }
    
    /// Get parameter bounds for an action type
    fn get_parameter_bounds(&self, action_type: &str) -> Option<ParameterBounds> {
        match action_type {
            "scale_queue" => Some(ParameterLimits::scale_queue()),
            "adjust_gossip" => Some(ParameterLimits::adjust_gossip()),
            "migrate_context" => Some(ParameterLimits::migrate_context()),
            _ => None,
        }
    }
    
    /// Get validation statistics
    pub fn get_stats(&self) -> (u64, u64) {
        (
            self.stats.load(std::sync::atomic::Ordering::Relaxed),
            self.failed_stats.load(std::sync::atomic::Ordering::Relaxed),
        )
    }
    
    /// Get validation success rate
    pub fn success_rate(&self) -> f64 {
        let total = self.stats.load(std::sync::atomic::Ordering::Relaxed);
        let failed = self.failed_stats.load(std::sync::atomic::Ordering::Relaxed);
        
        if total == 0 {
            return 1.0;
        }
        
        (total - failed) as f64 / total as f64
    }
}

impl Default for DecisionValidator {
    fn default() -> Self {
        Self::new()
    }
}

impl DecisionValidatorTrait for DecisionValidator {
    fn validate_decision(&self, decision: &Decision, decision_type: DecisionType) -> ValidationResult {
        self.stats.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        
        let mut errors = Vec::new();
        
        // Validate format
        if let Err(e) = self.validate_format(decision) {
            errors.push(ValidationErrorDetails::new(
                "format",
                "valid decision format",
                &e.to_string(),
            ));
        }
        
        // Validate each action
        for (i, action) in decision.actions.iter().enumerate() {
            if let Err(e) = self.validate_action(action, decision_type) {
                errors.push(
                    ValidationErrorDetails::new(
                        "action",
                        &format!("valid action at index {}", i),
                        &e.to_string(),
                    )
                    .with_field(&action.action_type),
                );
            }
        }
        
        if errors.is_empty() {
            debug!(
                decision = %decision.decision,
                confidence = decision.confidence,
                actions = decision.actions.len(),
                "Decision validated successfully"
            );
            ValidationResult::Valid
        } else {
            self.failed_stats.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
            
            if self.log_failures {
                warn!(
                    decision = %decision.decision,
                    error_count = errors.len(),
                    "Decision validation failed"
                );
                for error in &errors {
                    warn!(
                        validation = %error.validation_type,
                        expected = %error.expected,
                        actual = %error.actual,
                        "Validation error"
                    );
                }
            }
            
            ValidationResult::Invalid {
                error: OrchestratorError::SchemaValidationError {
                    message: format!("{} validation errors", errors.len()),
                    field: None,
                },
                details: errors,
            }
        }
    }
    
    fn validate_action(&self, action: &Action, decision_type: DecisionType) -> OrchestratorResult<()> {
        // Check action type is not empty
        if action.action_type.is_empty() {
            return Err(OrchestratorError::SchemaValidationError {
                message: "Action type cannot be empty".to_string(),
                field: Some("action_type".to_string()),
            });
        }
        
        // Check action is allowed for this decision type
        self.validate_action_allowed(action, decision_type)?;
        
        // Check priority
        self.validate_priority(action)?;
        
        // Check safety limits
        self.check_safety_limits(action)?;
        
        Ok(())
    }
    
    fn check_safety_limits(&self, action: &Action) -> OrchestratorResult<()> {
        // Get parameter bounds for this action type
        let bounds = match self.get_parameter_bounds(&action.action_type) {
            Some(b) => b,
            None => return Ok(()), // No specific bounds for this action
        };
        
        // Check each parameter
        for (param_name, value) in &action.parameters {
            if let Some(num) = value.as_i64() {
                if !bounds.check(param_name, num) {
                    if let Some((min, max)) = bounds.get_bounds(param_name) {
                        return Err(OrchestratorError::ParameterOutOfBounds {
                            param_name: param_name.clone(),
                            value: num.to_string(),
                            min: min.to_string(),
                            max: max.to_string(),
                        });
                    }
                }
            }
        }
        
        Ok(())
    }
    
    fn get_fallback_decision(&self, context: &str, decision_type: DecisionType) -> Decision {
        info!(
            context_len = context.len(),
            decision_type = %decision_type,
            "Generating fallback decision"
        );
        
        // Safe, conservative fallback
        Decision::new(
            "wait".to_string(),
            0.5,
            format!(
                "Fallback decision: Unable to generate {} decision for context. \
                 Recommending wait and monitor approach.",
                decision_type
            ),
            vec![Action::new("wait", 3)],
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn create_valid_decision() -> Decision {
        Decision::new(
            "scale_queue".to_string(),
            0.85,
            "Queue is approaching capacity, scaling recommended".to_string(),
            vec![
                Action::new("scale_queue", 5)
                    .with_param("new_size", serde_json::json!(150)),
            ],
        )
    }

    fn create_invalid_confidence_decision() -> Decision {
        Decision {
            id: "test".to_string(),
            decision: "test".to_string(),
            confidence: 1.5, // Invalid: > 1.0
            reasoning: "test".to_string(),
            actions: vec![],
            estimated_impact: None,
            rollback_plan: None,
            timestamp: chrono::Utc::now(),
        }
    }

    #[test]
    fn test_validate_valid_decision() {
        let validator = DecisionValidator::new();
        let decision = create_valid_decision();
        
        let result = validator.validate_decision(&decision, DecisionType::Infrastructure);
        assert!(result.is_valid());
    }

    #[test]
    fn test_validate_invalid_confidence() {
        let validator = DecisionValidator::new();
        let decision = create_invalid_confidence_decision();
        
        let result = validator.validate_decision(&decision, DecisionType::Infrastructure);
        assert!(!result.is_valid());
    }

    #[test]
    fn test_validate_disallowed_action() {
        let validator = DecisionValidator::new();
        let decision = Decision::new(
            "arbitrate".to_string(),
            0.8,
            "Conflict resolution".to_string(),
            vec![Action::new("arbitrate", 5)], // Not allowed for Infrastructure
        );
        
        let result = validator.validate_decision(&decision, DecisionType::Infrastructure);
        assert!(!result.is_valid());
    }

    #[test]
    fn test_validate_allowed_action_for_mediation() {
        let validator = DecisionValidator::new();
        let decision = Decision::new(
            "arbitrate".to_string(),
            0.8,
            "Conflict resolution".to_string(),
            vec![Action::new("arbitrate", 5)],
        );
        
        let result = validator.validate_decision(&decision, DecisionType::Mediation);
        assert!(result.is_valid());
    }

    #[test]
    fn test_validate_parameter_bounds() {
        let validator = DecisionValidator::new();
        
        // Valid parameter
        let action = Action::new("scale_queue", 5)
            .with_param("new_size", serde_json::json!(500));
        assert!(validator.check_safety_limits(&action).is_ok());
        
        // Invalid parameter (too large)
        let action = Action::new("scale_queue", 5)
            .with_param("new_size", serde_json::json!(5000));
        assert!(validator.check_safety_limits(&action).is_err());
        
        // Invalid parameter (too small)
        let action = Action::new("scale_queue", 5)
            .with_param("new_size", serde_json::json!(0));
        assert!(validator.check_safety_limits(&action).is_err());
    }

    #[test]
    fn test_validate_priority() {
        let validator = DecisionValidator::new();
        
        // Valid priority
        let action = Action::new("wait", 5);
        assert!(validator.validate_priority(&action).is_ok());
        
        // Invalid priority (too high)
        let mut action = Action::new("wait", 15);
        action.priority = 15;
        assert!(validator.validate_priority(&action).is_err());
        
        // Invalid priority (zero)
        let mut action = Action::new("wait", 0);
        action.priority = 0;
        assert!(validator.validate_priority(&action).is_err());
    }

    #[test]
    fn test_validate_empty_decision() {
        let validator = DecisionValidator::new();
        let decision = Decision {
            id: "test".to_string(),
            decision: "".to_string(), // Empty
            confidence: 0.5,
            reasoning: "".to_string(), // Empty
            actions: vec![],
            estimated_impact: None,
            rollback_plan: None,
            timestamp: chrono::Utc::now(),
        };
        
        let result = validator.validate_decision(&decision, DecisionType::Infrastructure);
        assert!(!result.is_valid());
    }

    #[test]
    fn test_validate_too_many_actions() {
        let validator = DecisionValidator::new();
        let decision = Decision::new(
            "test".to_string(),
            0.5,
            "test".to_string(),
            (0..10).map(|_| Action::new("wait", 3)).collect(), // 10 actions
        );
        
        let result = validator.validate_decision(&decision, DecisionType::Infrastructure);
        assert!(!result.is_valid());
    }

    #[test]
    fn test_fallback_decision() {
        let validator = DecisionValidator::new();
        let fallback = validator.get_fallback_decision(
            "test context",
            DecisionType::Infrastructure,
        );
        
        assert_eq!(fallback.decision, "wait");
        assert_eq!(fallback.confidence, 0.5);
        assert!(!fallback.actions.is_empty());
    }

    #[test]
    fn test_validation_stats() {
        let validator = DecisionValidator::new();
        
        let valid = create_valid_decision();
        let invalid = create_invalid_confidence_decision();
        
        validator.validate_decision(&valid, DecisionType::Infrastructure);
        validator.validate_decision(&invalid, DecisionType::Infrastructure);
        
        let (total, failed) = validator.get_stats();
        assert_eq!(total, 2);
        assert_eq!(failed, 1);
        assert!((validator.success_rate() - 0.5).abs() < 0.01);
    }

    #[test]
    fn test_validate_json() {
        let validator = DecisionValidator::new();
        
        let valid_json = r#"{
            "decision": "wait",
            "confidence": 0.8,
            "reasoning": "All good",
            "actions": []
        }"#;
        
        let result = validator.validate_json(valid_json);
        assert!(result.is_ok());
        
        let invalid_json = "not valid json";
        let result = validator.validate_json(invalid_json);
        assert!(result.is_err());
    }
}

