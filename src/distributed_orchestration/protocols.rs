//! P2P Protocols for Distributed Orchestration
//!
//! Defines message types and protocols for LLM-to-LLM consensus and coordination.

use super::types::{ConsensusResult, DecisionContext, NodeId, Proposal};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Protocol version
pub const PROTOCOL_VERSION: &str = "1.0.0";

/// GossipSub topics
pub mod topics {
    pub const CONSENSUS: &str = "/distributed-orchestration/consensus/1.0.0";
    pub const GROUPS: &str = "/distributed-orchestration/groups/1.0.0";
    pub const COORDINATION: &str = "/distributed-orchestration/coordination/1.0.0";
    pub const HEARTBEAT: &str = "/distributed-orchestration/heartbeat/1.0.0";
}

/// Consensus protocol messages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsensusMessage {
    /// Node proposes a decision (generated by local LLM)
    Proposal {
        id: String,
        node_id: NodeId,
        decision: String,
        confidence: f64,
        reasoning: String,
        context: DecisionContext,
        llm_model: String,
        timestamp: DateTime<Utc>,
    },
    
    /// Node votes on proposals
    Vote {
        proposal_id: String,
        node_id: NodeId,
        tendency: f64,
        threshold: f64,
        preferred_proposal: String,
    },
    
    /// Coordinator announces consensus reached
    ConsensusReached {
        proposal_id: String,
        decision: String,
        confidence: f64,
        participants: Vec<NodeId>,
        winning_reasoning: String,
    },
    
    /// Consensus failed to be reached
    ConsensusFailed {
        proposal_id: String,
        reason: String,
        fallback_decision: Option<String>,
    },
}

impl ConsensusMessage {
    /// Create a proposal message
    pub fn proposal(
        node_id: NodeId,
        decision: String,
        confidence: f64,
        reasoning: String,
        context: DecisionContext,
        llm_model: String,
    ) -> Self {
        Self::Proposal {
            id: uuid::Uuid::new_v4().to_string(),
            node_id,
            decision,
            confidence,
            reasoning,
            context,
            llm_model,
            timestamp: Utc::now(),
        }
    }
    
    /// Create a vote message
    pub fn vote(
        proposal_id: String,
        node_id: NodeId,
        tendency: f64,
        threshold: f64,
        preferred_proposal: String,
    ) -> Self {
        Self::Vote {
            proposal_id,
            node_id,
            tendency,
            threshold,
            preferred_proposal,
        }
    }
    
    /// Create a consensus reached message
    pub fn consensus_reached(
        proposal_id: String,
        decision: String,
        confidence: f64,
        participants: Vec<NodeId>,
        winning_reasoning: String,
    ) -> Self {
        Self::ConsensusReached {
            proposal_id,
            decision,
            confidence,
            participants,
            winning_reasoning,
        }
    }
    
    /// Create a consensus failed message
    pub fn consensus_failed(
        proposal_id: String,
        reason: String,
        fallback_decision: Option<String>,
    ) -> Self {
        Self::ConsensusFailed {
            proposal_id,
            reason,
            fallback_decision,
        }
    }
}

/// Group management messages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GroupMessage {
    /// Announce group formation
    GroupFormed {
        group_id: String,
        context: String,
        leader: NodeId,
        members: Vec<NodeId>,
        timestamp: DateTime<Utc>,
    },
    
    /// Request to join a group
    JoinRequest {
        group_id: String,
        node_id: NodeId,
        specializations: Vec<String>,
    },
    
    /// Response to join request
    JoinResponse {
        group_id: String,
        node_id: NodeId,
        accepted: bool,
        reason: Option<String>,
    },
    
    /// Leader election within group
    LeaderElection {
        group_id: String,
        candidate: NodeId,
        affinity_score: f64,
    },
    
    /// Cross-context coordination request
    CrossContextRequest {
        request_id: String,
        from_group: String,
        to_groups: Vec<String>,
        job_context: String,
        timestamp: DateTime<Utc>,
    },
    
    /// Cross-context coordination response
    CrossContextResponse {
        request_id: String,
        from_group: String,
        decision: String,
        confidence: f64,
    },
    
    /// Group dissolved
    GroupDissolved {
        group_id: String,
        reason: String,
        timestamp: DateTime<Utc>,
    },
}

/// Coordination messages
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CoordinationMessage {
    /// Announce affinity score
    AffinityAnnouncement {
        node_id: NodeId,
        affinity_score: f64,
        capacity: f64,
        latency_ms: u64,
        uptime_secs: u64,
        timestamp: DateTime<Utc>,
    },
    
    /// Coordinator claim
    CoordinatorClaim {
        node_id: NodeId,
        affinity_score: f64,
        term: u64,
    },
    
    /// Coordinator acknowledgment
    CoordinatorAck {
        node_id: NodeId,
        coordinator: NodeId,
        term: u64,
    },
    
    /// Coordinator resignation
    CoordinatorResign {
        node_id: NodeId,
        reason: String,
        successor: Option<NodeId>,
    },
    
    /// State sync request
    StateSyncRequest {
        node_id: NodeId,
        last_known_state_hash: String,
    },
    
    /// State sync response
    StateSyncResponse {
        node_id: NodeId,
        state_hash: String,
        state_data: Vec<u8>,
    },
}

/// Heartbeat message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeartbeatMessage {
    pub node_id: NodeId,
    pub timestamp: DateTime<Utc>,
    pub is_coordinator: bool,
    pub groups: Vec<String>,
    pub load: f64,
}

impl HeartbeatMessage {
    pub fn new(node_id: NodeId, is_coordinator: bool, groups: Vec<String>, load: f64) -> Self {
        Self {
            node_id,
            timestamp: Utc::now(),
            is_coordinator,
            groups,
            load,
        }
    }
}

/// Convert Proposal to ConsensusMessage::Proposal
impl From<Proposal> for ConsensusMessage {
    fn from(p: Proposal) -> Self {
        ConsensusMessage::Proposal {
            id: p.id,
            node_id: p.node_id,
            decision: p.decision,
            confidence: p.confidence,
            reasoning: p.reasoning,
            context: DecisionContext::default(),
            llm_model: "unknown".to_string(),
            timestamp: p.timestamp,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_consensus_message_serialization() {
        let msg = ConsensusMessage::proposal(
            "node-1".to_string(),
            "accept_job".to_string(),
            0.9,
            "High confidence based on available resources".to_string(),
            DecisionContext::default(),
            "llama-3.2".to_string(),
        );
        
        let json = serde_json::to_string(&msg).unwrap();
        let parsed: ConsensusMessage = serde_json::from_str(&json).unwrap();
        
        if let ConsensusMessage::Proposal { confidence, .. } = parsed {
            assert_eq!(confidence, 0.9);
        } else {
            panic!("Expected Proposal");
        }
    }
    
    #[test]
    fn test_heartbeat_message() {
        let msg = HeartbeatMessage::new(
            "node-1".to_string(),
            true,
            vec!["translation".to_string()],
            0.5,
        );
        
        let json = serde_json::to_string(&msg).unwrap();
        let parsed: HeartbeatMessage = serde_json::from_str(&json).unwrap();
        
        assert_eq!(parsed.node_id, "node-1");
        assert!(parsed.is_coordinator);
    }
    
    #[test]
    fn test_group_message() {
        let msg = GroupMessage::GroupFormed {
            group_id: "group-1".to_string(),
            context: "translation".to_string(),
            leader: "node-1".to_string(),
            members: vec!["node-1".to_string(), "node-2".to_string()],
            timestamp: Utc::now(),
        };
        
        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains("GroupFormed"));
    }
}

